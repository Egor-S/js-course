# База данных
Почти любое приложение имеет потребность в хранении информации. Для этих целей существуют базы данных. Самой простой из них явялется `SQLite`, так как не требует установки сервера. Для доступа к базе данных будем использовать ORM Sequelize - фреймворк, позволяющий избежать написание SQL запросов.

## Sequelize
### Установка
Для подключения модуля `sequelize` необходимо выполнить в папке проекта следующие команды:

```
$ npm install --save sequelize
$ npm install --save sqlite3
```

> Опция `--save` добавляет зависимость в файл `package.json`.

### Структура моделей
В корне проекта необходимо создать папку `models`, а внутри файл `index.js` (он будет выполняться при подключении модуля). Позже в этой папке будут размещаться файлы с моделями. Код `index.js` универсален, за исключением места подключения к базе данных:

```javascript
var fs = require("fs");
var path = require("path");
var Sequelize = require("sequelize");
// Подключение к базе данных
var sequelize = new Sequelize('sqlite://database.sqlite');

var db = {};

// Поиск всех файлов-моделей в текущей директории
fs
    .readdirSync(__dirname)
    .filter(function(file) {
        return (file.indexOf(".") !== 0) && (file !== "index.js");
    })
    .forEach(function(file) {
        var model = sequelize.import(path.join(__dirname, file));
        db[model.name] = model;
    });

// Настройка связей между моделями
Object.keys(db).forEach(function(modelName) {
    if ("associate" in db[modelName]) {
        db[modelName].associate(db);
    }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
```

Ниже приведен пример кода модели (каждая модель в собственном файле в папке `models`):

```javascript
module.exports = function(sequelize, DataTypes){
    var User = sequelize.define('User', {
        login: {
            type: DataTypes.STRING,
            unique: true
        },
        password: {
            type: DataTypes.STRING
        }
    });
    // Для настройки связей между моделями
    User.associate = function(models){
        User.hasMany(models.Message);
    };
    return User;
};
```

В файле `bin/www.js` нужно "обернуть" код запуска сервера в код синхронизации моделей с таблицами:

```javascript
var models = require('../models');
...
models.sequelize.sync().then(function () {
    server.listen(port);
    server.on('error', onError);
    server.on('listening', onListening);
});
```

### Модель
Модели описывают устройство таблиц в базе данных и связи между ними. Для создания моделей используется метод `sequelize.define()`. Первым аргументом передается название модели, а вторым объект, описывающий ее.

Для синхронизации моделей и таблиц используется метод `sequelize.sync()`.

> По умолчанию `sequelize` автоматически создает и обновляет поля `createdAt` и `updatedAt`.

### Запросы
API запросов Sequelize построено на Promise. Рассмотрим работу с моделями из маршрутов (например, `routes/index.js`):

```javascript
var models = require('../models');
```

Создание объекта:

```javascript
models.User.create({login: 'bob', password: 'pass'})
	.then(function(user){
		// Объект user сохранен в базе данных
	});
```

Получение объектов по запросу:

```javascript
models.User.findAll({
		attributes: ["login"],  // Запрашиваемые поля
		where: {
			password: '12345'  // Условие выборки
		}
	})
	.then(function(list){
		... 
	});
```

Обновление данных:

```javascript
models.User.update({
		password: 'strongpass'  // Изменение полей
	},
	{
		where: {
			login: 'alice'  // Условие выборки
		}
	})
	.then(function(){
		...
	});

// Если уже получен объект user
user.password = 'strongpass';
user.save();
```

Удаление объектов:

```javascript
models.User.destroy({
		where: {
			login: 'bob'  // Условие выборки
		}
	});

// Если уже получен объект user
user.destroy();
```

### Отношения между моделями
Существует три типа отношений между моделями:

1. **Один-к-одному**. Взаимнооднозначная связь между двумя моделями.
2. **Один-ко-многим**. Одной модели соответствует несколько других моделей, но эти модели уже не могут соответствовать кому-то еще. Самый распространенный вариант. (Пример: у пользователя несколько сообщений, но у сообщения только один автор)
3. **Многие-ко-многим**. Любая модель одного типа может иметь отношения с моделями другого типа. Требуется промежуточная модель. (Пример: в чате несколько участников, у участников несколько чатов)

С точки зрения базы данных, отношения между записями в таблицах реализованы через первичные ключи (`primary key`). В случае один-ко-многим в таблице "многие" добавляется поле `foreign key` с первичным ключом из другой таблицы.

Для создания отношений в предложенной выше структуре моделей необходимо определить метод `associate`. Ниже представлен пример для отношения один-ко-многим:

```javascript
User.associate = function(models){
        User.hasMany(models.Message);
    };
```

```javascript
Message.associate = function(models){
        Message.belongsTo(models.User, {
            onDelete: 'CASCADE'
        });
    };
```

> Каскадный режим удалит все сообщения пользователя, если удалить этого пользователя.

В методы отношений моделей первым аргументом передается связываемая модель, а вторым объект настроек. Рассмотрим доступные настройки для метода `belongsTo()`:

- `as` устанавливает название поля, указывающее на связываемую модель (автоматически меняется поле `foreign key`)
- `foreignKey` переопределяет название поля с внешним ключом (по умолчанию `'название модели'` + `'Id'`)
- `targetKey` определят, что использовать в качестве первичного ключа в связываемой модели

> Названием модели является строка, переданная в метод `sequelize.define()`

После применения методов для создания связей модели получают дополнительные методы получения и назначения связываемых моделей. Для примера выше это будут:

- `user.getMessages()`
- `user.setMessages()`
- `message.getUser()`
- `message.setUser()`

При запросе `findAll()` можно сразу загрузить связанные модели с помощью `include`:

```javascript
models.Message.findAll({
		attributes: ['text', 'createdAt'],
		include: [{
			model: models.User,
			attributes: ['login']
		}]
	})
	.then(function(list){
		// Можно получить имя автора: list[i].User.login
	});
```

## Авторизация
Авторизация служит для определения прав пользователя и нахождения данных, принадлежащих ему. В рамках протокола HTTP процесс авторизации выглядит следующим образом:

1. Пользователь отправляет логин и пароль
2. После успешной проверки создается уникальный идентификатор сессии, который записывается в `cookie` браузера
3. При получении запроса от пользователя сверяется запись в `cookie`  с записью в базе данных
4. В случае нахождения такой сессии в БД пользователь получает доступ и связанную с ним информацию

Хранить пароль в открытом виде - не безопасно: необходимо посчитать хэш от пароля и хранить его. При процессе проверки пароля сверяется хэш в базе данных и хэш пароля, полученного от пользователя. В идеальном случае вместо простой хэш-функции используется алгоритм `PBKDF2`.

## Безопасность
Любая информация полученная от пользователя имеет низший уровень доверия. Все пришедшие данные необходимо проверить (длинна пароля, пустые поля, соответсвие типов и т.д.). В противном случае это может привести к падению приложения или его взлому.

## Полезные ссылки
