# WebSockets
Большим недостатоком протокола HTTP/1.1 является невозможность отправлять со стороны сервера сообщения пользователю без предварительного запроса. Для исправления этого недостатка существует протокол WebSockets, поддерживаемый всеми современными браузерами.

## Socket.io
`socket.io` - библиотека для работы с протоколом WebSockets. По факту представляет из себя надстройку над этим протоколом. Вся рутина связанная с обслуживанием соединения скрыта от разработчика.

### Установка
Установка производится с помощью пакетного менеджера в папке проекта.

```
$ npm install socket.io --save
```

### Структура
Функционал связанный с WebSockets вынесем в отдельный файл `routes/sockets.js`:

```javascript
var io = require('socket.io')();

io.on('connection', function(socket){
    console.log('new WS connection');
    ...
});

module.exports = io;
```

В файле `app.js` сохраним модуль в объект приложения:

```javascript
var sockets = require('./routes/sockets.js');
app.socket_io = sockets;
```

В файле `bin/www.js` присоединим объект сервера к модулю:

```javascript
var io = app.socket_io;
io.attach(server);
```

### Принцип работы
При отправке сообщения указывается событие. На другой стороне сообщение получит обработчик, настроенный на это событие. В примере выше событие `connection` отправяется самой библиотекой.

Обработчики событий создаются привычным для JavaScript способом - с помощью callback-функций.

В случае работы по протоколу WebSockets: устанавливается соединение, которое не разрывается до окончания работы, поэтому сервер имеет возможность отправить сообщение в любой момент.

В случае, если браузер не поддерживает WebSockets будет использоваться Long Polling - запрос клиента удерживается в незавершенном состоянии, пока не появится информация для пользователя. После этого пользователь снова отправяет запрос.

###  Сторона клиента
Для использования библиотеки необходимо подключить соответствующий js-файл:

```html
<script src="/socket.io/socket.io.js"></script>
```

Далее создается объект `socket` (происходит автоматическое подключение) и настраиваются обработчики событий:

```javascript
var socket = io();

socket.on('message', function(msg){
	// msg - сообщение от сервера
});
```

Для отправки сообщения используется метод `emit()`. Также необходимо указать событие:

```javascript
socket.emit('answer', {msg: 'Hello', author: 'Bob'});
```

> Передавать можно не только строки, но и другие стандартные типы JavaScript

Основные события, предусмотренные `socket.io`:

- `connect` - произошло успешное подключение
- `error` - произошла ошибка
- `disconnect` - произошло отключение

### Сторона сервера
Код обработчиков будем писать в файле `routes/sockets.js`. Часть отвечающая за прием соеднинений уже написана (`app.js` и `bin/www.js`).

Главное отличие серверного кода от клиентского состоит в расположении обработчиков. В случае сервера добавление всех обработчиков происходит внутри обработчика `connect`, причем добавляются они к полученному объекту соединения:

```javascript
io.on('connection', function(socket){
    console.log('new WS connection');
    
    /* User handlers */
    socket.on('disconnect', function(){
        console.log('WS connection lost');
    });
    socket.on('msg', function(msg){
    	console.log('new message');
    });
});
```

На стороне сервера существует три основных варианта отправки 
сообщения:

**Одному пользователю**

```javascript
socket.emit('msg', 'text');
```

**Всем подключенным пользователям**

```javascript
io.emit('msg', 'text');
```

**Всем, кроме одного пользователя**

```javascript
socket.broadcast.emit('msg', 'text');
```

В объект `socket` можно добавлять поля, которые будут доступны из обработчиков (например, id пользователя в БД).
Объект `socket.request` содержит информацию о соединении (включая `cookie` браузера для этого домаена).

## Полезные ссылки 